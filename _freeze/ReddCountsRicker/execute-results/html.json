{
  "hash": "6176301cd647f22291277f5cbbad61b4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Stock-Recruitment Analysis\"\nformat: html\n---\n\n\n\n\n\n\nPurpose: Fit hierarchical Ricker stock-recruitment model to understand environmental effects on population productivity\n\n**Notes:**\n\n* Model is fit with managed winter flow variation as the only winter flow variable. \n  + Managed winter flow variables (*jld_winmean*, *jld_winmin*, and *jld_winvar*) are all strongly correlated and alternative models fit with each produce similar results (*no effect of managed winter flow*)\n  + However, traceplots for global covariate effects for the model with *jld_winvar* indicate better convergence than for alternative models\n* An alternative option for dealing with correlated managed flow variables would be to fit a model with a \"management regime\" binary variable indicating pre- and post-1989 change in JLD autumn ramp-down and winter flow management. \n* For all models, ~bi-modal posterior distributions for select global covariate effects (*jld_peakmag* in particular) suggest that the effects of certain covariates may differ between ages. \n  + More exploratory modeling may be warranted. For example, we could treat the base model as an \"exploratory\" analysis, then after seeing posterior distributions, estimate age-specific effects for problematic variables. Although this complicates the interaction term between managed and natural peak flow magnitude. \n* It may be worth considering other natural flow variables, such as annual/winter minimum flow per Clark comment (+), but this may be correlated with managed minimum flows, and combined mean winter flow is correlated with jld_peaktime (?). Additionally, Diana suggests end of summer natural base flow (+), but this is likely correlated with natural peak flow magnitude \n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n## Data\n\nFirst, use this to pull fish data\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- read_csv(\"Data/Derived/ReddCounts_WGFD_1971-2021_cleaned_withFlowTempCovariates_SeparateFlowComponents_age0.csv\")\n```\n:::\n\n\n\n\n\n\nPull covariate data for age-0, combine experienced and natural flow datasets\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat0 <- read_csv(\"Data/Derived/ReddCounts_WGFD_1971-2021_cleaned_withFlowTempCovariates_SeparateFlowComponents_age0.csv\")\ndat0b <- read_csv(\"Data/Derived/ReddCounts_WGFD_1971-2021_cleaned_withFlowTempCovariates_ExperiencedFlow_age0.csv\") %>%\n  select(year, stream, natq_winmean, natq_winvar, natq_peakmag, natq_peaktime, z_natq_winmean, z_natq_winvar, z_natq_peakmag, z_natq_peaktime) %>%\n  rename(expq_winmean = natq_winmean,\n         expq_winvar = natq_winvar,\n         expq_peakmag = natq_peakmag,\n         expq_peaktime = natq_peaktime,\n         z_expq_winmean = z_natq_winmean,\n         z_expq_winvar = z_natq_winvar,\n         z_expq_peakmag = z_natq_peakmag,\n         z_expq_peaktime = z_natq_peaktime)\ndat0 <- dat0 %>% left_join(dat0b)\n```\n:::\n\n\n\n\n\n\nPull covariate data for age-1, combine experienced and natural flow datasets\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 <- read_csv(\"Data/Derived/ReddCounts_WGFD_1971-2021_cleaned_withFlowTempCovariates_SeparateFlowComponents_age1.csv\")\ndat1b <- read_csv(\"Data/Derived/ReddCounts_WGFD_1971-2021_cleaned_withFlowTempCovariates_ExperiencedFlow_age1.csv\") %>%\n  select(year, stream, natq_winmean, natq_winvar, natq_peakmag, natq_peaktime, z_natq_winmean, z_natq_winvar, z_natq_peakmag, z_natq_peaktime) %>%\n  rename(expq_winmean = natq_winmean,\n         expq_winvar = natq_winvar,\n         expq_peakmag = natq_peakmag,\n         expq_peaktime = natq_peaktime,\n         z_expq_winmean = z_natq_winmean,\n         z_expq_winvar = z_natq_winvar,\n         z_expq_peakmag = z_natq_peakmag,\n         z_expq_peaktime = z_natq_peaktime)\ndat1 <- dat1 %>% left_join(dat1b)\n```\n:::\n\n\n\n\n\n\nDrop Cody (very little data), Salt River tribs, and \"ghost years\"\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- dat %>% \n  filter(!stream %in% c(\"Cody\", \"Christiansen\", \"Dave\", \"Laker\")) %>%\n  filter(!(stream == \"Cowboy Cabin\" & year %in% c(1980:1981))) %>%\n  filter(!(stream == \"Flat\" & year %in% c(1976:1979))) %>%\n  filter(!(stream == \"Spring\" & year %in% c(1988:1992)))\n```\n:::\n\n\n\n\n\n\nCreate summary table\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary.dat <- dat %>% filter(!is.na(reddsperkm)) %>% group_by(stream) %>% summarize('lat' = unique(lat), 'long' = unique(long), 'startyr' = min(year), 'endyr' = max(year), 'n.year' = length(unique(year))) %>% arrange(stream) %>% ungroup()\ndatatable(summary.dat)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-9f59bcf940138fba95bd\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-9f59bcf940138fba95bd\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\"],[\"3 Channel\",\"Blacktail\",\"Blue Crane\",\"Cowboy Cabin\",\"Fish\",\"Flat\",\"Little Bar BC\",\"Lower Bar BC\",\"Nowlin\",\"Price\",\"Snake River Side Channel\",\"Spring\",\"Upper Bar BC\"],[43.55623017,43.66881478,43.42787225,43.72893903,43.5467974,43.54300482,43.54701598,43.54628223,43.52638051,43.56333321,43.683012,43.4270652,43.67985923],[-110.7882611,-110.6986929,-110.8246243,-110.6741424,-110.8469954,-110.7255992,-110.7867088,-110.7843594,-110.7321466,-110.792471,-110.70152,-110.8209696,-110.7077563],[1973,1973,1985,1982,1984,1980,1978,1971,1976,1975,1986,1993,1974],[2014,2016,2015,2016,2016,2015,2016,2021,2015,2006,2002,2007,2016],[31,33,26,30,24,28,34,39,29,24,17,13,39]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>stream<\\/th>\\n      <th>lat<\\/th>\\n      <th>long<\\/th>\\n      <th>startyr<\\/th>\\n      <th>endyr<\\/th>\\n      <th>n.year<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[2,3,4,5,6]},{\"orderable\":false,\"targets\":0},{\"name\":\" \",\"targets\":0},{\"name\":\"stream\",\"targets\":1},{\"name\":\"lat\",\"targets\":2},{\"name\":\"long\",\"targets\":3},{\"name\":\"startyr\",\"targets\":4},{\"name\":\"endyr\",\"targets\":5},{\"name\":\"n.year\",\"targets\":6}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n\n```{.r .cell-code}\nwrite_csv(summary.dat, \"ReddCounts_DataSummary.csv\")\n```\n:::\n\n\n\n\n\n\n\nPlot stock-recruit data\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- ggplot(dat, aes(x = reddsperkm_lag4, y = reddsperkm, color = broodyr)) +\n  theme_bw() +\n  geom_smooth(color = \"black\") +\n  geom_point(alpha = 0.75) +\n  facet_wrap(~ stream, scales = 'free', ncol = 4) +\n  xlab('Spawning redd density (redds/km)') +\n  ylab('Recruitment redd density (redds/km)') +\n  theme(panel.grid = element_blank())\nplot(g)\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-7-1.png){width=768}\n:::\n:::\n\n\n\n\n\n\n\n\nPlot productivity by stock/spawners\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- ggplot(dat, aes(x = reddsperkm_lag4, y = log(reddsperkm/reddsperkm_lag4), color = broodyr)) +\n  theme_bw() +\n  geom_smooth(method ='lm', color = \"black\") +\n  geom_point(alpha = 0.75) +\n  facet_wrap(~ stream, scales = 'free', ncol = 4) +\n  xlab('Spawning redd density (redds/km)') +\n  ylab('ln(Recruits/Spawner)') +\n  theme(panel.grid = element_blank())\nplot(g)\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-9-1.png){width=768}\n:::\n:::\n\n\n\n\n\n\n\n\nAdd misc. variables (currently not used in the model)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# JLD mgmt regime\ndat <- dat %>% mutate(regime = ifelse(year < 1989, 0, 1))\n\n# Distance from JLD\ndjld <- read_csv(\"Flowline Distance/ReddCount_Sites_JLDDistance.csv\") %>%\n  filter(!stream %in% c(\"Dave\", \"Snake River Side Channel\", \"Spring\"))\n```\n:::\n\n\n\n\n\n\nHow much of the variation in productivity is explained by density-dependence alone? (*sensu* Jones *et al.* 2020)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 <- dat %>% mutate(lnRS = log(reddsperkm / reddsperkm_lag4), \n                       stream = as_factor(stream))\nsummary(lm(lnRS ~ reddsperkm_lag4 + stream:reddsperkm_lag4, dat2)) # ~37%\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = lnRS ~ reddsperkm_lag4 + stream:reddsperkm_lag4, \n    data = dat2)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-2.65491 -0.32585  0.04252  0.32878  2.16889 \n\nCoefficients:\n                                                Estimate Std. Error t value\n(Intercept)                                     1.059469   0.087723  12.078\nreddsperkm_lag4                                -0.012519   0.002065  -6.063\nreddsperkm_lag4:streamBlacktail                 0.009026   0.001984   4.550\nreddsperkm_lag4:streamBlue Crane               -0.050926   0.008190  -6.218\nreddsperkm_lag4:streamCowboy Cabin             -0.013250   0.004807  -2.757\nreddsperkm_lag4:streamFish                     -0.010025   0.003744  -2.678\nreddsperkm_lag4:streamFlat                     -0.044523   0.008485  -5.247\nreddsperkm_lag4:streamLittle Bar BC            -0.017217   0.003412  -5.046\nreddsperkm_lag4:streamNowlin                   -0.014566   0.003740  -3.895\nreddsperkm_lag4:streamPrice                    -0.016379   0.004442  -3.687\nreddsperkm_lag4:streamSnake River Side Channel -0.015236   0.004466  -3.411\nreddsperkm_lag4:streamSpring                   -0.010905   0.004186  -2.605\nreddsperkm_lag4:streamUpper Bar BC              0.004217   0.002015   2.093\nreddsperkm_lag4:streamLower Bar BC              0.005705   0.001978   2.884\n                                               Pr(>|t|)    \n(Intercept)                                     < 2e-16 ***\nreddsperkm_lag4                                4.79e-09 ***\nreddsperkm_lag4:streamBlacktail                8.32e-06 ***\nreddsperkm_lag4:streamBlue Crane               2.05e-09 ***\nreddsperkm_lag4:streamCowboy Cabin             0.006262 ** \nreddsperkm_lag4:streamFish                     0.007895 ** \nreddsperkm_lag4:streamFlat                     3.25e-07 ***\nreddsperkm_lag4:streamLittle Bar BC            8.58e-07 ***\nreddsperkm_lag4:streamNowlin                   0.000126 ***\nreddsperkm_lag4:streamPrice                    0.000277 ***\nreddsperkm_lag4:streamSnake River Side Channel 0.000751 ***\nreddsperkm_lag4:streamSpring                   0.009720 ** \nreddsperkm_lag4:streamUpper Bar BC             0.037376 *  \nreddsperkm_lag4:streamLower Bar BC             0.004260 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.6103 on 255 degrees of freedom\n  (189 observations deleted due to missingness)\nMultiple R-squared:  0.3973,\tAdjusted R-squared:  0.3666 \nF-statistic: 12.93 on 13 and 255 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Format Fish Data\n\nLog annual redd count data and calculate number of years per population\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# log \ndat <- dat %>% mutate(rcraw_log = log(reddsperkm))\n\n# how many years of data does each pop have?\ndatatable(dat %>% drop_na(rcraw_log) %>% group_by(stream) %>% summarize(nyr = n_distinct(rcraw_log)))\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-31f8a1b51bf8f02ca37a\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-31f8a1b51bf8f02ca37a\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\"],[\"3 Channel\",\"Blacktail\",\"Blue Crane\",\"Cowboy Cabin\",\"Fish\",\"Flat\",\"Little Bar BC\",\"Lower Bar BC\",\"Nowlin\",\"Price\",\"Snake River Side Channel\",\"Spring\",\"Upper Bar BC\"],[31,33,24,29,24,26,29,39,28,24,15,13,37]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>stream<\\/th>\\n      <th>nyr<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":2},{\"orderable\":false,\"targets\":0},{\"name\":\" \",\"targets\":0},{\"name\":\"stream\",\"targets\":1},{\"name\":\"nyr\",\"targets\":2}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n\n\nFormat fish data into matrices for JAGS model\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# specify populations\npops <- sort(unique(dat$stream))\nn.pops <- length(pops)\n\n# specify years\nn.years <- vector(length = n.pops)\nyears <- matrix(nrow = n.pops, ncol = 51)\nfor(p in 1:n.pops) {\n  n.years[p] <- length(unique(dat$year[dat$stream == pops[p]]))\n  years[p,1:n.years[p]] <- sort(unique(dat$year[dat$stream == pops[p]]))\n}\n\n# Spawners and Recruits\nrec_raw <- matrix(nrow = n.pops, ncol = max(n.years)) \n# rec_cor <- matrix(nrow = n.pops, ncol = max(n.years))\n# rec_cor_sd <- matrix(nrow = n.pops, ncol = max(n.years))\nfor(p in 1:n.pops) {\n  for(y in 1:n.years[p]) {\n    year <- years[p,y]\n    rec_raw[p,y] <- dat$rcraw_log[dat$stream == pops[p] & dat$year == year] # Raw, uncorrected ecruits (log scale)\n    # rec_cor[p,y] <- dat$rccor_log_mean[dat$stream == pops[p] & dat$year == year] # Corrected recruits (log scale)\n    # rec_cor_sd[p,y] <- dat$rccor_log_sd[dat$stream == pops[p] & dat$year == year] # recruitment uncertainty\n  }#next y\n}#next p\n```\n:::\n\n\n\n\n\n\nGet maximum spawners for initialization\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaxY <- apply(exp(rec_raw), 1, max, na.rm = TRUE)\nmeanY <- apply(exp(rec_raw), 1, mean, na.rm = TRUE)\n```\n:::\n\n\n\n\n\n\nCheck dimensions\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(years)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13 51\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(rec_raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13 51\n```\n\n\n:::\n\n```{.r .cell-code}\n# dim(rec_cor)\n# dim(rec_cor_sd)\n```\n:::\n\n\n\n\n\n\n\n## Format Covariate Data\n\nFor age apportionment model (split covariate effects among ages 0 and 1), set up two arrays of covariates: one for covariates lagged to reflect conditions during age-0 (4 years) and another for covariates lagged to reflect conditions during age-1 (3 years)\n\nGet covariate names\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# names.covars1 <- grep(\"z\", names(dat0), value = TRUE)[c(1:3,5:8,11,14:19)] # age-0\n# names.covars0 <- grep(\"z\", names(dat0), value = TRUE)[c(1:3,5:8,14:15,20,16:19)] # age-0\n# names.covars0 <- grep(\"z\", names(dat0), value = TRUE)[c(1:3,5:8,20,14:19)] # age-0\nnames.covars0 <- grep(\"z\", names(dat0), value = TRUE)[c(1:2,6,7:9,15:20)]#[c(2:3,5,7:9,15:20)] # age-0\n# names.covars2 <- grep(\"z\", names(dat1), value = TRUE)[c(1:3,5:8,11,14:19)] # age-1\n# names.covars1 <- grep(\"z\", names(dat0), value = TRUE)[c(1:3,5:8,14:15,20,16:19)] # age-1\n# names.covars1 <- grep(\"z\", names(dat0), value = TRUE)[c(1:3,5:8,20,14:19)] # age-1\nnames.covars1 <- grep(\"z\", names(dat1), value = TRUE)[c(1:2,6,7:9,15:20)]#[c(2:3,5,7:9,15:20)] # age-1\n\nprint(names.covars1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"z_jld_rampdur\"        \"z_jld_rampratemindoy\" \"z_jld_winvar\"        \n [4] \"z_jld_summean\"        \"z_jld_peakmag\"        \"z_jld_peaktime\"      \n [7] \"z_natq_peakmag\"       \"z_natq_peaktime\"      \"z_temp_falmean\"      \n[10] \"z_temp_winmean\"       \"z_temp_sprmean\"       \"z_temp_summean\"      \n```\n\n\n:::\n:::\n\n\n\n\n\n\nFormat covariate data into matrices for JAGS model\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn.covars <- length(names.covars0)\ncovars0 <- array(data = NA, dim = c(n.pops, max(n.years), n.covars))\ncovars1 <- array(data = NA, dim = c(n.pops, max(n.years), n.covars))\nfor(p in 1:n.pops) {\n  for(y in 1:n.years[p]) {\n    yr <- years[p,y]\n    for(c in 1:n.covars) {\n      covars0[p,y,c] <- as.numeric(dat0 %>% select(stream, year, names.covars0[c]) %>% filter(stream == pops[p] & year == yr) %>% select(3))\n      covars1[p,y,c] <- as.numeric(dat1 %>% select(stream, year, names.covars1[c]) %>% filter(stream == pops[p] & year == yr) %>% select(3))\n    } # next c\n  } # next y\n  #print(p)\n} # next p\ndim(covars0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13 51 12\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(covars1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13 51 12\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAdd interaction and/or squared terms, if applicable\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# names.covars0 <- c(names.covars0, \"z_int_peaktime\", \"z_int_peakmag\") # add names for additional terms\n# names.covars1 <- c(names.covars1, \"z_int_peaktime\", \"z_int_peakmag\") # add names for additional terms\n# covars0 <- abind::abind(covars0, covars0[,,6]*covars0[,,9], covars0[,,5]*covars0[,,8], along = 3)\n# covars1 <- abind::abind(covars1, covars1[,,6]*covars1[,,9], covars1[,,5]*covars1[,,8], along = 3)\n# n.covars <- length(names.covars0)\n\nnames.covars0 <- c(names.covars0, \"z_int_peakmag\", \"z_int_peaktime\") # add names for additional terms\nnames.covars1 <- c(names.covars1, \"z_int_peakmag\", \"z_int_peaktime\") # add names for additional terms\ncovars0 <- abind::abind(covars0, covars0[,,5]*covars0[,,7], covars0[,,6]*covars0[,,8], along = 3)\ncovars1 <- abind::abind(covars1, covars1[,,5]*covars1[,,7], covars0[,,6]*covars0[,,8], along = 3)\nn.covars <- length(names.covars0)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# OLD - NOT USED\n# # set up covariate array\n# names.covars <- grep(\"z\", names(dat), value = TRUE)[c(1:8,11,14:19)] # for separated flow components\n# names.covars <- grep(\"z\", names(dat), value = TRUE)[c(1:5,7:12)] # for experienced flow\n# names.covars <- grep(\"z\", names(dat), value = TRUE)[c(1:3,5:8,11,14:19)]\n# names.covars <- grep(\"z\", names(dat), value = TRUE)[c(1:3,14:19)]\n# \n# \n# n.covars <- length(names.covars)\n# covars <- array(data = NA, dim = c(n.pops, max(n.years), n.covars))\n# for(p in 1:n.pops) {\n#   for(y in 1:n.years[p]) {\n#     yr <- years[p,y]\n#     for(c in 1:n.covars) {\n#       covars[p,y,c] <- as.numeric(dat %>% select(stream, year, names.covars[c]) %>% filter(stream == pops[p] & year == yr) %>% select(3))\n#     } # next c\n#   } # next y\n#   print(p)\n# } # next p\n# dim(covars)\n# \n# # (for separate flow components) Full interaction model: add array slices for squared terms, interaction terms\n# names.covars <- c(names.covars, \"z_int_peakmag\", \"z_int_peaktime\", \"z_int_winmeanflow\", \"z_int_jldwinmeanvar\") # add names for additional terms\n# covars <- abind::abind(covars, covars[,,7]*covars[,,10], covars[,,8]*covars[,,11], covars[,,4]*covars[,,9], covars[,,4]*covars[,,5], along = 3)\n# n.covars <- length(names.covars)\n# \n# # (for experienced flow) Full interaction model: add array slices for squared terms, interaction terms\n# names.covars <- c(names.covars, \"z_int_winflowmeanvar\", \"z_int_peakmagtime\") # add names for additional terms\n# covars <- abind::abind(covars, covars[,,4]*covars[,,5], covars[,,6]*covars[,,7], along = 3)\n# n.covars <- length(names.covars)\n# \n# names.covars <- c(names.covars, \"z_int_peakmag\", \"z_int_peaktime\", \"z_int_winmeanvar\") # add names for additional terms\n# covars <- abind::abind(covars, covars[,,5]*covars[,,7], covars[,,6]*covars[,,8], covars[,,13]*covars[,,14], along = 3)\n# n.covars <- length(names.covars)\n# \n# # check dimensions\n# dim(covars)\n# \n# # create matrix for pre/post 1989\n# regime <- matrix(data = NA, nrow = nrow(years), ncol = ncol(years))\n# for (i in 1:nrow(regime)) { for (j in 1:ncol(regime)) { regime[i,j] <- ifelse(years[i,j] < 1989, 0, 1) }}\n# # names.covars <- c(names.covars, \"regime\")\n# # covars <- abind::abind(covars, regime, along = 3)\n# # n.covars <- length(names.covars)\n\n# plot(covars1[,,1] ~ covars2[,,1])\n# plot(covars1[,,2] ~ covars2[,,2])\n# plot(covars1[,,3] ~ covars2[,,3])\n# plot(covars1[,,4] ~ covars2[,,4])\n# plot(covars1[,,5] ~ covars2[,,5])\n# plot(covars1[,,6] ~ covars2[,,6])\n# plot(covars1[,,7] ~ covars2[,,7])\n# plot(covars1[,,8] ~ covars2[,,8])\n# plot(covars1[,,9] ~ covars2[,,9])\n# plot(covars1[,,10] ~ covars2[,,10])\n# plot(covars1[,,11] ~ covars2[,,11])\n# plot(covars1[,,12] ~ covars2[,,12])\n# plot(covars1[,,13] ~ covars2[,,13])\n# plot(covars1[,,14] ~ covars2[,,14])\n```\n:::\n\n\n\n\n\n\nAdd empty columns for model initialization\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# recruitment\nrec_raw <- cbind(matrix(NA, nrow = nrow(rec_raw), ncol = 4), rec_raw)\n# rec_cor <- cbind(matrix(NA, nrow = nrow(rec_cor), ncol = 4), rec_cor)\n# rec_cor_sd <- cbind(matrix(NA, nrow = nrow(rec_cor_sd), ncol = 4), rec_cor_sd)\n\n# covariates\n# rl <- list()\n# for (i in 1:dim(covars)[3]) { rl[[i]] <- cbind(matrix(NA, nrow = nrow(covars), ncol = 4), covars[,,i]) }\n# covars <- abind::abind(rl, along = 3)\nrl <- list()\nfor (i in 1:dim(covars0)[3]) { rl[[i]] <- cbind(matrix(NA, nrow = nrow(covars0), ncol = 4), covars0[,,i]) }\ncovars0 <- abind::abind(rl, along = 3)\nrl <- list()\nfor (i in 1:dim(covars1)[3]) { rl[[i]] <- cbind(matrix(NA, nrow = nrow(covars1), ncol = 4), covars1[,,i]) }\ncovars1 <- abind::abind(rl, along = 3)\n\n# years\nn.years <- n.years + 4\n\n# regime\n# regime <- cbind(matrix(NA, nrow = nrow(regime), ncol = 4), regime)\n```\n:::\n\n\n\n\n\n\nCheck dimensions\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check dimensions\ndim(rec_raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13 55\n```\n\n\n:::\n\n```{.r .cell-code}\n# dim(rec_cor)\n# dim(rec_cor_sd)\n# dim(covars)\ndim(covars0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13 55 14\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(covars1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13 55 14\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(n.years)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Model in JAGS\n\n### Specify JAGS model\n\nState-space hierarchical Ricker stock-recruitment model with auto-correlated residuals, where observation error is an estimated parameter. Covariates can affect productivity at either age-0 or age-1, with a parameter that estimates the relative importance of effects at each age class. Observations are distributed log-normally around (latent, phases 1-2) redd densities. Log-log scale ensures positive values and allows sigma.oe to be estimated on a log-scale and directly compared to net error model estimates of redd count error from Baldock *et al.* (2023 CJFAS): 0.38 (mean and 95% CI = 0.34, 0.44)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"model {\n\n##--- LIKELIHOOD ---------------------------------------------------##\n\n# OBSERVATION PROCESS\nfor (j in 1:numPops) {\n    for (i in 1:numYears[j]) {\n        logY0[j,i] ~ dnorm(logY[j,i], pow(sigma.oe, -2)) \n        N[j,i] <- exp(logY[j,i])\n        }\n    }\n\n# STATE PROCESS\nfor (j in 1:numPops) {\n\n    # STARTING VALUES / INITIALIZATION\n    Y1[j] ~ dunif(1, maxY[j])\n    Y2[j] ~ dunif(1, maxY[j])\n    Y3[j] ~ dunif(1, maxY[j])\n    Y4[j] ~ dunif(1, maxY[j])\n    logY[j,1] <- log(Y1[j])\n    logY[j,2] <- log(Y2[j])\n    logY[j,3] <- log(Y3[j])\n    logY[j,4] <- log(Y4[j])\n\n    logresid[j,4] <- 0\n\n    # ALL OTHER YEARS\n    for (i in 5:numYears[j]) {\n\n        # Derive population and year specific covariate effects \n        for (c in 1:numCovars) { \n            covars0[j,i,c] ~ dnorm(0, pow(1, -2))\n            covars1[j,i,c] ~ dnorm(0, pow(1, -2))\n            cov.eff[j,i,c] <- coef[j,c] * (((1-p[c]) * covars0[j,i,c]) + (p[c] * covars1[j,i,c])) }\n        \n        # Likelihood and predictions\n        logY[j,i] ~ dnorm(logpred2[j,i], pow(sigma.pe[j], -2))\n        logpred[j,i] <- logY[j,i-4] + A[j] - B[j] * exp(logY[j,i-4]) + sum(cov.eff[j,i,1:numCovars])\n        \n        # save observations and latent states in loop to exclude starting values from model object\n        loglatent[j,i] <- logY[j,i]\n        logobserv[j,i] <- logY0[j,i]\n        \n        # Auto-correlated residuals\n        logresid[j,i] <- logY[j,i] - logpred[j,i]\n        logpred2[j,i] <- logpred[j,i] + logresid[j,i-1] * phi[j]\n        logresid2[j,i] <- logY[j,i] - logpred2[j,i]\n        \n        # Log-likelihood\n        loglik[j,i] <- logdensity.norm(logY0[j,i], logY[j,i], pow(sigma.oe, -2))\n        }\n    }\n\n\n##--- PRIORS --------------------------------------------------------##\n\n# Observation error is shared among populations, constrained prior...consider centering this on Baldock et al (2023) CJFAS estimate\nsigma.oe ~ dunif(0.001, 100) #dnorm(0, pow(0.5, -2)) T(0,)\n\n# Population-specific parameters\nfor (j in 1:numPops) {\n\n    # Ricker A\n    #expA[j] ~ dunif(0, 20)\n    #A[j] <- log(expA[j])\n    A[j] ~ dnorm(mu.A, pow(sigma.A, -2)) \n\n    # Ricker B\n    B[j] ~ dnorm(0, pow(1, -2)) T(0,)\n    #B[j] ~ dnorm(mu.B, pow(sigma.B, -2))\n\n    # Covariate effects\n    for (c in 1:numCovars) { coef[j,c] ~ dnorm(mu.coef[c], pow(sigma.coef[c], -2)) }\n\n    # Process error\n    sigma.pe[j] ~ dunif(0.001, 100) #dnorm(0, pow(5, -2)) T(0,)\n\n    # auto-correlated residuals\n    phi[j] ~ dunif(-0.99, 0.99)\n\n    }\n\n# Global Ricker A and B\nmu.A <- log(exp.mu.A) #dunif(0, 20)\nexp.mu.A ~ dunif(0, 20)\nsigma.A ~ dunif(0.001, 100)\n#mu.B ~ dnorm(0, pow(1, -2)) T(0,)\n#sigma.B ~ dunif(0.001, 100)\n\n# Global covariate effects\nfor (c in 1:numCovars) { \n    mu.coef[c] ~ dnorm(0, pow(25, -2)) \n    sigma.coef[c] ~ dunif(0.001, 100) #dnorm(0, pow(5, -2)) T(0.001,100)\n    p[c] ~ dunif(0, 1)\n    }\n\n\n##--- DERIVED QUANTITIES ---------------------------------------------##\n\n# Population specific carrying capacity\nfor (j in 1:numPops) { K[j] <- A[j] / B[j] }\n\n}\", file = \"JAGS Models/Ricker_Hierarchical_StateSpace_OEestimated_Covars_Proportional.txt\")\n```\n:::\n\n\n\n\n\n\n\nSame as above, but covariates only affect productivity at age-0\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"model {\n\n##--- LIKELIHOOD ---------------------------------------------------##\n\n# OBSERVATION PROCESS\nfor (j in 1:numPops) {\n    for (i in 1:numYears[j]) {\n        logY0[j,i] ~ dnorm(logY[j,i], pow(sigma.oe, -2)) \n        N[j,i] <- exp(logY[j,i])\n        }\n    }\n\n# STATE PROCESS\nfor (j in 1:numPops) {\n\n    # STARTING VALUES / INITIALIZATION\n    Y1[j] ~ dunif(1, maxY[j])\n    Y2[j] ~ dunif(1, maxY[j])\n    Y3[j] ~ dunif(1, maxY[j])\n    Y4[j] ~ dunif(1, maxY[j])\n    logY[j,1] <- log(Y1[j])\n    logY[j,2] <- log(Y2[j])\n    logY[j,3] <- log(Y3[j])\n    logY[j,4] <- log(Y4[j])\n\n    logresid[j,4] <- 0\n\n    # ALL OTHER YEARS\n    for (i in 5:numYears[j]) {\n\n        # Derive population and year specific covariate effects \n        for (c in 1:numCovars) { \n            covars[j,i,c] ~ dnorm(0, pow(1, -2))\n            cov.eff[j,i,c] <- coef[j,c] * covars[j,i,c] }\n        \n        # Likelihood and predictions\n        logY[j,i] ~ dnorm(logpred2[j,i], pow(sigma.pe[j], -2))\n        logpred[j,i] <- logY[j,i-4] + A[j] - B[j] * exp(logY[j,i-4]) + sum(cov.eff[j,i,1:numCovars])\n                \n        # save observations and latent states in loop to exclude starting values from model object\n        loglatent[j,i] <- logY[j,i]\n        logobserv[j,i] <- logY0[j,i]\n        \n        # Auto-correlated residuals\n        logresid[j,i] <- logY[j,i] - logpred[j,i]\n        logpred2[j,i] <- logpred[j,i] + logresid[j,i-1] * phi[j]\n        logresid2[j,i] <- logY[j,i] - logpred2[j,i]\n        \n        # Log-likelihood\n        loglik[j,i] <- logdensity.norm(logY0[j,i], logY[j,i], pow(sigma.oe, -2))\n        }\n    }\n\n\n##--- PRIORS --------------------------------------------------------##\n\n# Observation error is shared among populations, constrained prior...consider centering this on Baldock et al (2023) CJFAS estimate\nsigma.oe ~ dunif(0.001, 100) #dnorm(0, pow(0.5, -2)) T(0,)\n\n# Population-specific parameters\nfor (j in 1:numPops) {\n\n    # Ricker A\n    #expA[j] ~ dunif(0, 20)\n    #A[j] <- log(expA[j])\n    A[j] ~ dnorm(mu.A, pow(sigma.A, -2)) \n\n    # Ricker B\n    B[j] ~ dnorm(0, pow(1, -2)) T(0,)\n    #B[j] ~ dnorm(mu.B, pow(sigma.B, -2))\n\n    # Covariate effects\n    for (c in 1:numCovars) { coef[j,c] ~ dnorm(mu.coef[c], pow(sigma.coef[c], -2)) }\n\n    # Process error\n    sigma.pe[j] ~ dunif(0.001, 100) #dnorm(0, pow(5, -2)) T(0,)\n\n    # auto-correlated residuals\n    phi[j] ~ dunif(-0.99, 0.99)\n\n    }\n\n# Global Ricker A and B\nmu.A <- log(exp.mu.A) #dunif(0, 20)\nexp.mu.A ~ dunif(0, 20)\nsigma.A ~ dunif(0.001, 100)\n#mu.B ~ dnorm(0, pow(1, -2)) T(0,)\n#sigma.B ~ dunif(0.001, 100)\n\n# Global covariate effects\nfor (c in 1:numCovars) { \n    mu.coef[c] ~ dnorm(0, pow(25, -2)) \n    sigma.coef[c] ~ dunif(0.001, 100) #dnorm(0, pow(5, -2)) T(0.001,100)\n    }\n\n\n##--- DERIVED QUANTITIES ---------------------------------------------##\n\n# Population specific carrying capacity\nfor (j in 1:numPops) { K[j] <- A[j] / B[j] }\n\n}\", file = \"JAGS Models/Ricker_Hierarchical_StateSpace_OEestimated_Covars.txt\")\n```\n:::\n\n\n\n\n\n\n\n### Age-0/1 Proportional\n\nParameters to monitor\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\njags.params <- c(\"A\", \"B\", \"K\", \"mu.A\", \"sigma.A\", \"sigma.oe\", \"sigma.pe\",   # Ricker parameters\n                 \"coef\", \"mu.coef\", \"sigma.coef\", \"cov.eff\", \"p\",            # covariate effects\n                 \"logpred\", \"logpred2\",                                      # predictions\n                 \"loglatent\", \"logobserv\",                                   # latent states and observations\n                 \"phi\", \"logresid\", \"logresid2\", \"loglik\")                   # AR1 term, residuals, log-likelihood\n```\n:::\n\n\n\n\n\n\nRun model in JAGS\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst <- Sys.time()\njags.data <- list(\"logY0\" = rec_raw, \"numYears\" = n.years, \"numPops\" = n.pops, \"maxY\" = maxY, \"covars0\" = covars0, \"covars1\" = covars1, \"numCovars\" = n.covars)\nmod_01pb <- jags.parallel(data = jags.data, inits = NULL, parameters.to.save = jags.params, \n                          model.file = \"JAGS Models/Ricker_Hierarchical_StateSpace_OEestimated_Covars_Proportional.txt\", \n                          n.chains = 20, n.thin = 200, n.burnin = 10000, n.iter = 60000, DIC = TRUE)\nMCMCtrace(mod_01pb, ind = TRUE, params = c(\"A\", \"B\", \"mu.A\", \"sigma.A\", \"sigma.oe\", \"sigma.pe\", \"mu.coef\", \"sigma.coef\", \"p\", \"phi\"),\n          filename = \"Model output/MCMCtrace_ReddCountsRicker_Test_Age01p_winvar.pdf\") # write out traceplots\nSys.time() - st\nbeep()\n```\n:::\n\n\n\n\n\n\nSave model output as RDS file\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(mod_01pb, \"Model output/ReddCountsRicker_Phase1_Age01p_winvar.RDS\")\n```\n:::\n\n\n\n\n\n\nRead in model RDS file\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_01pb <- readRDS(\"Model output/ReddCountsRicker_Phase1_Age01p_winvar.RDS\")\n```\n:::\n\n\n\n\n\n\nCheck R-hat values\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_01pb$BUGSoutput$summary[,8][mod_01pb$BUGSoutput$summary[,8] > 1.05]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  K[11] \n1.28153 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n### Age-0 only\n\n*NOT CURRENTLY USED*\n\nParameters to monitor\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\njags.params <- c(\"A\", \"B\", \"K\", \"mu.A\", \"sigma.A\", \"sigma.oe\", \"sigma.pe\",   # Ricker parameters\n                 \"coef\", \"mu.coef\", \"sigma.coef\", \"cov.eff\",            # covariate effects\n                 \"logpred\", \"logpred2\",                                      # predictions\n                 \"loglatent\", \"logobserv\",                                   # latent states and observations\n                 \"phi\", \"logresid\", \"logresid2\", \"loglik\")                   # AR1 term, residuals, log-likelihood\n```\n:::\n\n\n\n\n\n\nRun model in JAGS\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst <- Sys.time()\njags.data <- list(\"logY0\" = rec_raw, \"numYears\" = n.years, \"numPops\" = n.pops, \"maxY\" = maxY, \"covars\" = covars0, \"numCovars\" = n.covars)\nmod_0 <- jags.parallel(data = jags.data, inits = NULL, parameters.to.save = jags.params, \n                          model.file = \"JAGS Models/Ricker_Hierarchical_StateSpace_OEestimated_Covars.txt\", \n                          n.chains = 20, n.thin = 200, n.burnin = 10000, n.iter = 40000, DIC = TRUE)\nMCMCtrace(mod_0, ind = TRUE, params = c(\"A\", \"B\", \"mu.A\", \"sigma.A\", \"sigma.oe\", \"sigma.pe\", \"mu.coef\", \"sigma.coef\", \"p\", \"phi\"),\n          filename = \"Model output/MCMCtrace_ReddCountsRicker_Test_Age0.pdf\") # write out traceplots\nSys.time() - st\nbeep()\n```\n:::\n\n\n\n\n\n\nCheck R-hat values\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_0$BUGSoutput$summary[,8][mod_0$BUGSoutput$summary[,8] > 1.05]\n```\n:::\n\n\n\n\n\n\nSave model output as RDS file\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(mod_0, \"Model output/ReddCountsRicker_Phase1_Age0.RDS\")\n```\n:::\n\n\n\n\n\n\nRead in model RDS file\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_0 <- readRDS(\"Redd Counts Ricker/Model output/ReddCountsRicker_Phase1_Age0.RDS\")\n```\n:::\n\n\n\n\n\n\n\n### LOO-CV\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nll.arr <- mod_01pb$BUGSoutput$sims.list$loglik # extract the log-likelihood estimates for each MCMC sample\nll.mat <- ll.arr[,,1]\nfor (j in 2:dim(ll.arr)[3]) {\n  ll.mat <- cbind(ll.mat, ll.arr[,,j])\n}\nrf <- relative_eff(exp(ll.mat), chain_id = rep(1:20, each = 250))\nmy_loo <- loo(ll.mat, r_eff = rf)\nplot(my_loo)\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n### Set top model\n\nSet top model and save MCMC samples and parameter summary\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntopmod <- mod_01pb\n\n# generate MCMC samples and store as an array\nmodelout <- topmod$BUGSoutput\nparam.summary <- modelout$summary\nMcmcList <- vector(\"list\", length = dim(modelout$sims.array)[2])\nfor(i in 1:length(McmcList)) {\n  McmcList[[i]] = as.mcmc(modelout$sims.array[,i,])\n}\n# rbind MCMC samples from 3 chains \nMcmcdat <- rbind(McmcList[[1]], McmcList[[2]], McmcList[[3]])\nparam.summary <- as.data.frame(modelout$summary)\n\n# save model output\nwrite_csv(as.data.frame(Mcmcdat), \"Model output/ReddCountsRicker_Phase1_Age01p_mcmcsamps.csv\")\nwrite.csv(as.data.frame(modelout$summary), \"Model output/ReddCountsRicker_Phase1_Age01p_ParameterSummary.csv\", row.names = T)\n```\n:::\n\n\n\n\n\n\n\n## Model Diagnostics\n\nGet expected and observed MCMC samples\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppdat_exp <- as.matrix(Mcmcdat[,startsWith(colnames(Mcmcdat), \"logpred2\")])\nppdat_obs <- as.matrix(Mcmcdat[,startsWith(colnames(Mcmcdat), \"loglatent\")])\n```\n:::\n\n\n\n\n\n\n\n### Residuals\n\nHistogram of residuals\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,1,1), mgp = c(2.5,1,0))\nhist((ppdat_obs - ppdat_exp), main = \"\", xlab = \"Observed - Expected\")\nlegend(\"topright\", bty = \"n\", legend = paste(\"Median Resid. = \", round(median((ppdat_obs - ppdat_exp)), digits = 4), sep = \"\"))\nabline(v = median(unlist(ppdat_obs - ppdat_exp)), col = \"red\", lwd = 2)\nbox(bty = \"o\")\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\n\n#### Before autocorrelation\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogresid <- matrix(data = NA, nrow = nrow(rec_raw), ncol = ncol(rec_raw)+4)\nfor (j in 1:nrow(rec_raw)) {\n  for (i in 1:ncol(rec_raw)+4) {\n    try(logresid[j,i] <- param.summary[paste(\"logresid[\",j,\",\",i,\"]\", sep = \"\"),1])\n  }\n}\n```\n:::\n\n\n\n\n\n\nTime series of residuals (AR1)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(4,4), mgp = c(2,0.8,0), mar = c(2.5, 3, 1.5, 0.5))\nfor (i in 1:n.pops) {\n  plot(logresid[i,c(5:55)] ~ years[i,c(1:51)], pch = 16, xlab = \"\", ylab = \"log residuals\", main = pops[i], xlim = c(1970, 2021), ylim = c(min(logresid, na.rm = T), max(logresid, na.rm = T)))\n  lines(logresid[i,c(5:55)] ~ years[i,c(1:51)])\n  abline(h = 0, lty = 2)\n}\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-41-1.png){width=768}\n:::\n:::\n\n\n\n\n\n\n\n\ntime series of residuals (AR1), unique y scale\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(4,4), mgp = c(2,0.8,0), mar = c(2.5, 3, 1.5, 0.5))\nfor (i in 1:n.pops) {\n  plot(logresid[i,c(5:55)] ~ years[i,c(1:51)], pch = 16, xlab = \"\", ylab = \"log residuals\", main = pops[i], xlim = c(1970, 2021))\n  lines(logresid[i,c(5:55)] ~ years[i,c(1:51)])\n  abline(h = 0, lty = 2)\n}\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-43-1.png){width=768}\n:::\n:::\n\n\n\n\n\n\n\n\n\n#### After autocorrelation\n\nResiduals AFTER accounting for autocorrelation sensu Murdoch et al 2024 CJFAS\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogresid <- matrix(data = NA, nrow = nrow(rec_raw), ncol = ncol(rec_raw)+4)\nfor (j in 1:nrow(rec_raw)) {\n  for (i in 1:ncol(rec_raw)+4) {\n    try(logresid[j,i] <- param.summary[paste(\"logresid2[\",j,\",\",i,\"]\", sep = \"\"),1])\n  }\n}\n```\n:::\n\n\n\n\n\n\ntime series of residuals (AR1)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(4,4), mgp = c(2,0.8,0), mar = c(2.5, 3, 1.5, 0.5))\nfor (i in 1:n.pops) {\n  plot(logresid[i,c(5:55)] ~ years[i,c(1:51)], pch = 16, xlab = \"\", ylab = \"log residuals\", main = pops[i], xlim = c(1970, 2021), ylim = c(min(logresid, na.rm = T), max(logresid, na.rm = T)))\n  lines(logresid[i,c(5:55)] ~ years[i,c(1:51)])\n  abline(h = 0, lty = 2)\n}\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-46-1.png){width=768}\n:::\n:::\n\n\n\n\n\n\n\n\n\ntime series of residuals (AR1), unique y scale\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(4,4), mgp = c(2,0.8,0), mar = c(2.5, 3, 1.5, 0.5))\nfor (i in 1:n.pops) {\n  plot(logresid[i,c(5:55)] ~ years[i,c(1:51)], pch = 16, xlab = \"\", ylab = \"log residuals\", main = pops[i], xlim = c(1970, 2021))\n  lines(logresid[i,c(5:55)] ~ years[i,c(1:51)])\n  abline(h = 0, lty = 2)\n}\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-48-1.png){width=768}\n:::\n:::\n\n\n\n\n\n\n\n\nShow residual autocorrelation plots by population\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(4,4), mgp = c(2,0.8,0), mar = c(3, 3, 0.5, 0.5))\nfor (i in 1:n.pops) {\n  pacf(logresid[i,][complete.cases(logresid[i,])], main = pops[i])\n}\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-50-1.png){width=768}\n:::\n:::\n\n\n\n\n\n\n### Bayesian p-value\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bayesian p-value\nsum(ppdat_exp > ppdat_obs) / (dim(ppdat_obs)[1]*dim(ppdat_obs)[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4857758\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### PP Check\n\nNote that this isn't a posterior predictive check in the true sense, but rather a comparison between the model-estimated latent states (log redd density) and the model predicted means. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,1,1), mgp = c(2.5,1,0))\nplot(x = seq(from = 1.5, to = 6.5, length.out = 100), y = seq(from = 1.5, to = 6.5, length.out = 100), pch = NA, xlab = \"Latent ln(recruitment)\", ylab = \"Median posterior expected ln(recruitment)\")\npoints(apply(ppdat_exp, 2, median, na.rm = T) ~ apply(ppdat_obs, 2, median, na.rm = T))\nlegend(\"topleft\", bty = \"n\", legend = paste(\"Bayesian p-value = \", round(sum(ppdat_exp > ppdat_obs) / (dim(ppdat_obs)[1]*dim(ppdat_obs)[2]), digits = 3), sep = \"\"))\nabline(a = 0, b = 1, col = \"red\", lwd = 2)\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\n\n## Plot Model Output\n\n### Time series fits\n\nPull latent and predicted abundance from model output\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set up matrices: latent states\nN_med <- matrix(data = NA, nrow = nrow(rec_raw), ncol = ncol(rec_raw)+4)\nN_low <- matrix(data = NA, nrow = nrow(rec_raw), ncol = ncol(rec_raw)+4)\nN_upp <- matrix(data = NA, nrow = nrow(rec_raw), ncol = ncol(rec_raw)+4)\n\n# set up matrices: predictions\nP_med <- matrix(data = NA, nrow = nrow(rec_raw), ncol = ncol(rec_raw)+4)\nP_low <- matrix(data = NA, nrow = nrow(rec_raw), ncol = ncol(rec_raw)+4)\nP_upp <- matrix(data = NA, nrow = nrow(rec_raw), ncol = ncol(rec_raw)+4)\n\n# pull latent and predicted abundance from parameter summary\nfor (j in 1:nrow(rec_raw)) {\n  for (i in 1:ncol(rec_raw)+4) {\n    # try(N_med[j,i] <- exp(param.summary[paste(\"loglatent[\",j,\",\",i,\"]\", sep = \"\"),5]))\n    # try(N_low[j,i] <- exp(param.summary[paste(\"loglatent[\",j,\",\",i,\"]\", sep = \"\"),3]))\n    # try(N_upp[j,i] <- exp(param.summary[paste(\"loglatent[\",j,\",\",i,\"]\", sep = \"\"),7]))\n    # \n    # try(P_med[j,i] <- exp(param.summary[paste(\"logpred2[\",j,\",\",i,\"]\", sep = \"\"),5]))\n    # try(P_low[j,i] <- exp(param.summary[paste(\"logpred2[\",j,\",\",i,\"]\", sep = \"\"),3]))\n    # try(P_upp[j,i] <- exp(param.summary[paste(\"logpred2[\",j,\",\",i,\"]\", sep = \"\"),7]))\n\n    loglatent <- NA\n    logpred2 <- NA\n    \n    try(loglatent <- Mcmcdat[,paste(\"loglatent[\",j,\",\",i,\"]\", sep = \"\")])\n    try(logpred2 <- Mcmcdat[,paste(\"logpred2[\",j,\",\",i,\"]\", sep = \"\")])\n    \n    try(N_med[j,i] <- quantile(exp(loglatent), prob = 0.50))\n    try(N_low[j,i] <- quantile(exp(loglatent), prob = 0.05))\n    try(N_upp[j,i] <- quantile(exp(loglatent), prob = 0.95))\n    \n    try(P_med[j,i] <- quantile(exp(logpred2), prob = 0.50))\n    try(P_low[j,i] <- quantile(exp(logpred2), prob = 0.05))\n    try(P_upp[j,i] <- quantile(exp(logpred2), prob = 0.95))\n    \n  }\n}\n```\n:::\n\n\n\n\n\n\nSet up and check color palette for color blindess accessibility\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrec <- rec_raw\npopshort <- c(\"THCH\", \"BLKT\", \"BLCR\", \"COCA\", \"FISH\", \"FLAT\", \"LTBC\", \"LOBC\", \"NOWL\", \"PRCE\", \"SRSC\", \"SPRG\", \"UPBC\")\nmycols <- c(\"orchid1\", \"forestgreen\")# c(\"darkorange\", \"dodgerblue\") # hcl.colors(2, \"Red-Green\")\npalette_check(col2hcl(mycols), plot = TRUE)\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          name n tolerance ncp ndcp min_dist mean_dist max_dist\n1       normal 2  85.67993   1    1 85.67993  85.67993 85.67993\n2 deuteranopia 2  85.67993   1    0 50.06492  50.06492 50.06492\n3   protanopia 2  85.67993   1    0 55.64110  55.64110 55.64110\n4   tritanopia 2  85.67993   1    0 56.34705  56.34705 56.34705\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPlot time series data with observations, latent states, and model fits.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(4,4), mgp = c(2,0.6,0), mar = c(1.2, 1.2, 2, 1.2), oma = c(2.5,2.5,0,0))\nfor (i in 1:n.pops) {\n  plot(exp(rec_raw[i,c(5:55)]) ~ years[i,c(1:51)], type = \"n\", xlab = \"\", ylab = \"\", xlim = c(1970, 2021), ylim = c(0, exp(max(rec_raw[i,], na.rm = T))))\n  title(popshort[i], line = 0.25)\n  # pop-specific years\n  yrpreds <- as.numeric(na.omit(years[i,c(1:51)]))#[1:(length(as.numeric(na.omit(years[i,c(1:51)])))-4)]\n  # pop-specific latent states\n  nmedpreds <- as.numeric(na.omit(N_med[i,c(5:55)]))\n  nlowpreds <- as.numeric(na.omit(N_low[i,c(5:55)]))\n  nupppreds <- as.numeric(na.omit(N_upp[i,c(5:55)]))\n  # pop-specific predictions\n  pmedpreds <- as.numeric(na.omit(P_med[i,c(5:55)]))\n  plowpreds <- as.numeric(na.omit(P_low[i,c(5:55)]))\n  pupppreds <- as.numeric(na.omit(P_upp[i,c(5:55)]))\n  # carrying capacity\n  abline(h = param.summary[paste(\"K[\",i,\"]\", sep = \"\"),5], lty = 3)\n  # plot latent states\n  lines(nmedpreds ~ yrpreds, lwd = 1.5, col = mycols[1])\n  polygon(x = c(yrpreds, rev(yrpreds)), y = c(c(nlowpreds), rev(nupppreds)), col = scales::alpha(mycols[1], 0.3), border = NA)\n  # plot predictions\n  lines(pmedpreds ~ yrpreds, lwd = 1.5, col = mycols[2])\n  polygon(x = c(yrpreds, rev(yrpreds)), y = c(c(plowpreds), rev(pupppreds)), col = scales::alpha(mycols[2], 0.3), border = NA)\n  # plot observations\n  points(exp(rec_raw[i,c(5:55)]) ~ years[i,c(1:51)], pch = 1)\n  # legend\n  #legend(\"topright\", legend = pops[i], bty = \"n\", border = NA, col = NA, fill = NA, cex = 1.25)\n}\nmtext(\"Year\", side = 1, line = 1, outer = T)\nmtext(expression(\"Redds km\"^-1), side = 2, line = 1, outer = T)\nplot.new()\nlegend(\"center\", legend = c(\"Observations\", \"Latent states\", \"Predictions\"), pch = c(1,NA,NA), lwd = c(NA,2,2), col = c(\"black\", mycols[1], mycols[2]), bty = \"n\", cex = 1.5)\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-56-1.png){width=816}\n:::\n:::\n\n\n\n\n\n\n\n\n\nPopulation summaries of latent states and carrying capacity, arranged from least to most variable (based on CV).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeans <- apply(N_med, 1, mean, na.rm = T)\nsds <- apply(N_med, 1, sd, na.rm = T)\ncvs <- sds/means\nmins <- apply(N_med, 1, min, na.rm = T)\nmaxs <- apply(N_med, 1, max, na.rm = T)\nrelc <- maxs/mins\nks <- param.summary[grep(\"K\", row.names(param.summary), value = TRUE),5]\n\npoptib <- tibble(pop = pops, mean = round(means, digits = 3), sd = round(sds, digits = 3), cv = round(cvs, digits = 3), min = round(mins, digits = 3), max = round(maxs, digits = 3), K = round(ks, digits = 3))\ndatatable(poptib %>% arrange(cv))\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-5ad6c714e85ae4663778\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-5ad6c714e85ae4663778\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\"],[\"Spring\",\"3 Channel\",\"Fish\",\"Blacktail\",\"Nowlin\",\"Blue Crane\",\"Upper Bar BC\",\"Price\",\"Snake River Side Channel\",\"Flat\",\"Cowboy Cabin\",\"Lower Bar BC\",\"Little Bar BC\"],[47.185,73.681,40.915,261.14,35.836,16.673,120.401,28.694,37.142,19.275,37.713,133.099,35.776],[9.423,18.96,10.931,82.495,12.455,6.539,50.271,12.692,16.703,9.462,19.413,71.56100000000001,20.307],[0.2,0.257,0.267,0.316,0.348,0.392,0.418,0.442,0.45,0.491,0.515,0.538,0.5679999999999999],[32.683,24.89,24.05,43.642,17.073,5.376,64.72799999999999,9.050000000000001,7.823,6.745,10.769,10.599,3.225],[68.896,132.103,61.228,419.867,61.683,36.904,313.555,62.537,66.907,45.892,96.09,357.815,80.935],[53.242,84.276,42.855,268.941,38.976,17.167,128.144,32.306,40.776,19.599,38.339,152.716,41.909]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>pop<\\/th>\\n      <th>mean<\\/th>\\n      <th>sd<\\/th>\\n      <th>cv<\\/th>\\n      <th>min<\\/th>\\n      <th>max<\\/th>\\n      <th>K<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[2,3,4,5,6,7]},{\"orderable\":false,\"targets\":0},{\"name\":\" \",\"targets\":0},{\"name\":\"pop\",\"targets\":1},{\"name\":\"mean\",\"targets\":2},{\"name\":\"sd\",\"targets\":3},{\"name\":\"cv\",\"targets\":4},{\"name\":\"min\",\"targets\":5},{\"name\":\"max\",\"targets\":6},{\"name\":\"K\",\"targets\":7}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Parameter dot plots\n\nCoerce to ggs object\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod.gg <- ggs(as.mcmc(topmod), keep_original_order = TRUE)\npopshort <- c(\"THCH\", \"BLKT\", \"BLCR\", \"COCA\", \"FISH\", \"FLAT\", \"LTBC\", \"LOBC\", \"NOWL\", \"PRCE\", \"SRSC\", \"SPRG\", \"UPBC\")\n```\n:::\n\n\n\n\n\n\nRemind covariate names...\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames.covars0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"z_jld_rampdur\"        \"z_jld_rampratemindoy\" \"z_jld_winvar\"        \n [4] \"z_jld_summean\"        \"z_jld_peakmag\"        \"z_jld_peaktime\"      \n [7] \"z_natq_peakmag\"       \"z_natq_peaktime\"      \"z_temp_falmean\"      \n[10] \"z_temp_winmean\"       \"z_temp_sprmean\"       \"z_temp_summean\"      \n[13] \"z_int_peakmag\"        \"z_int_peaktime\"      \n```\n\n\n:::\n:::\n\n\n\n\n\n\nCovariate types and pretty covariate names\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nCovType <- factor(c(rep(\"Managed flow\", times = 6), \n                    rep(\"Natural flow\", times = 2), \n                    rep(\"Temperature\", times = 4), \n                    rep(\"Interaction\", times = 2)),\n                  levels = c(\"Managed flow\", \"Natural flow\", \"Temperature\", \"Interaction\"))\n\n# rename covariates\nnames.covars.new <- c(\"Duration of ramp down\", \"Timing of ramp down\", \n                      \"Mgd. winter flow var.\", \"Mgd. summer mean flow\", \"Mgd. peak flow mag.\", \"Mgd. peak flow timing\", \n                      \"Nat. peak flow mag.\", \"Nat. peak flow timing\",\n                      \"Autumn temperature\", \"Winter temperature\", \"Spring temperature\", \"Summer temperature\",\n                      \"Mgd. x Nat. peak flow mag.\", \"Mgd. x Nat. peak flow timing\")\n```\n:::\n\n\n\n\n\n\nSet color palette\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# bls <- hcl.colors(5, \"Blues3\")\n# mycols <- c(\"darkorange\", bls[c(3,1)], \"seagreen\", \"grey50\")\nmycols <- c(\"#E69F00\", \"#56B4E9\", \"#009E73\", \"#999999\")\n#palette_check(col2hcl(mycols), plot = TRUE)\n```\n:::\n\n\n\n\n\n\n#### Global covariate effects\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggs_caterpillar(D = mod.gg, family = \"mu.coef\", thick_ci = c(0.125, 0.875), thin_ci = c(0.025, 0.975), sort = FALSE) + \n  theme_bw() + ylab(\"Environmental driver\") + xlab(\"Global change in productivity, ln(R/S)\") + aes(color = CovType) + scale_color_manual(values = mycols) +\n  geom_vline(xintercept = 0, linetype = \"dashed\") + scale_y_discrete(labels = rev(names.covars.new), limits = rev) +\n  theme(legend.position = \"top\", legend.title = element_blank(), axis.text = element_text(color = \"black\"),\n        legend.key.spacing.y = unit(0, \"cm\"), legend.key.spacing.x = unit(1, \"cm\"), legend.margin = margin(0,0,0,0)) + \n  guides(color = guide_legend(nrow = 2, byrow = TRUE))\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-63-1.png){width=528}\n:::\n:::\n\n\n\n\n\n\n\n\n\n#### Population covariate effects\n\nDefine colors\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmycols2 <- c(rep(mycols[1], times = 6), rep(mycols[2], times = 2), \n             rep(mycols[3], times = 4), rep(mycols[4], times = 2))\n```\n:::\n\n\n\n\n\n\nGenerate plots in a for loop\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generate plots in a for loop\nfor (i in 1:length(names.covars0)) {\n  jpeg(paste(\"Figures/Dot Plots/Pop Level Covariate Effects/ReddCounts_Ricker_CovarModel_DotPlot_Covs\", i, \"_\", names.covars0[i], \".jpg\", sep = \"\"), units = \"in\", width = 5, height = 5, res = 1500)\n  print(ggs_caterpillar(D = mod.gg %>% filter(Parameter %in% paste(\"coef[\", 1:16, \",\", i, \"]\", sep = \"\")), family = \"coef\", thick_ci = c(0.125, 0.875), thin_ci = c(0.025, 0.975), sort = FALSE) + \n          theme_bw() + ylab(\"\") + xlab(\"Effect\") + ggtitle(names.covars.new[i]) + scale_y_discrete(labels = rev(pops), limits = rev) + geom_vline(xintercept = 0, linetype = \"dashed\") + \n          aes(color = CovType[i]) + scale_color_manual(values = mycols2[i]) + theme(legend.position = \"none\", plot.title = element_text(hjust = 0.5), axis.text = element_text(color = \"black\")))\n  dev.off()\n}\n```\n:::\n\n\n\n\n\n\nCombined plot\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncovplots <- list()\npopshort <- c(\"THCH\", \"BLKT\", \"BLCR\", \"COCA\", \"FISH\", \"FLAT\", \"LTBC\", \"LOBC\", \"NOWL\", \"PRCE\", \"SRSC\", \"SPRG\", \"UPBC\")\nfor (i in 1:length(names.covars0)) {\n  p1 <- eval(substitute(ggs_caterpillar(D = mod.gg %>% filter(Parameter %in% paste(\"coef[\", 1:16, \",\", i, \"]\", sep = \"\")), family = \"coef\", thick_ci = c(0.125, 0.875), thin_ci = c(0.025, 0.975), sort = FALSE) + \n                          theme_bw() + ylab(\"\") + xlab(\"\") + xlim(-0.55, 0.49) + ggtitle(names.covars.new[i]) + geom_vline(xintercept = 0, linetype = \"dashed\") + \n                          scale_y_discrete(labels = rev(popshort), limits = rev) + aes(color = CovType[i]) + scale_color_manual(values = mycols2[i]) + \n                          theme(legend.position = \"none\", plot.margin = unit(c(0.1,0.1,-0.7,-0.5), 'lines'), plot.title = element_text(vjust = -0.5, hjust = 0.5), axis.text = element_text(color = \"black\")), list(i = i)))\n  covplots[[i]] <- p1\n}\nmyfig <- ggarrange(plotlist = covplots, ncol = 4, nrow = 4)\nmyfig\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-67-1.png){width=1056}\n:::\n:::\n\n\n\n\n\n\n\n\n\n#### Population variation in covariate effects\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggs_caterpillar(D = mod.gg, family = \"sigma.coef\", thick_ci = c(0.125, 0.875), thin_ci = c(0.025, 0.975), sort = FALSE) + \n  theme_bw() + ylab(\"Environmental driver\") + xlab(\"Population-level variation in covariate effect\") + aes(color = CovType) + scale_color_manual(values = mycols) +\n  geom_vline(xintercept = 0, linetype = \"dashed\") + scale_y_discrete(labels = rev(names.covars.new), limits = rev) +\n  theme(legend.position = \"top\") + theme(legend.title = element_blank(), axis.text = element_text(color = \"black\"), \n        legend.key.spacing.y = unit(0, \"cm\"), legend.key.spacing.x = unit(1, \"cm\"), legend.margin = margin(0,0,0,0))  + \n  guides(color = guide_legend(nrow = 2, byrow = TRUE))\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-69-1.png){width=528}\n:::\n:::\n\n\n\n\n\n\n\n\n\n#### Age proportional effects\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_tibble(Mcmcdat[, c(\"p[1]\", \"p[2]\", \"p[3]\", \"p[4]\", \"p[5]\", \"p[6]\", \"p[7]\", \"p[8]\", \"p[9]\", \n                      \"p[10]\", \"p[11]\", \"p[12]\", \"p[13]\", \"p[14]\")]) %>%\n  gather(key = \"param\", value = \"value\") %>% mutate(param = fct_rev(as_factor(param))) %>% \n  ggplot(aes(x = value, y = param, height = stat(density), fill = param)) + \n  geom_density_ridges(scale = 1.3, stat = \"density\", alpha = 0.8) +\n  scale_fill_manual(values = rev(mycols2)) + scale_y_discrete(labels = rev(names.covars.new), expand = expand_scale(mult = c(0.01, .07))) +\n  ylab(\"Environmental driver\") + xlab(expression(paste(\"Proportional effect at age-0 vs. age-1 (\", rho, \")\"))) +\n  theme_bw() + theme(legend.position = \"none\", axis.text = element_text(color = \"black\"), \n        legend.key.spacing.y = unit(0, \"cm\"), legend.key.spacing.x = unit(1, \"cm\"), legend.margin = margin(0,0,0,0), panel.grid = element_blank())  + \n  guides(color = guide_legend(nrow = 2, byrow = TRUE))\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-71-1.png){width=480}\n:::\n\n```{.r .cell-code}\n# same but plot as density/ridgelines\nmycols2 <- c(mycols[1], mycols[1], mycols[1], mycols[1], mycols[1], mycols[1], mycols[2], mycols[2], mycols[3], mycols[3], mycols[3], mycols[3], mycols[4], mycols[4])\n# mycols2 <- c(\"darkorange\", \"darkorange\", bls[3], bls[3], bls[3], bls[3], bls[1], bls[1], \"seagreen\", \"seagreen\", \"seagreen\", \"seagreen\", \"grey50\", \"grey50\")\njpeg(\"Figures/Dot Plots/ReddCounts_Ricker_CovarModel_DensityPlot_ProportionalCov.jpg\", units = \"in\", width = 5, height = 7, res = 1500)\nas_tibble(Mcmcdat[, c(\"p[1]\", \"p[2]\", \"p[3]\", \"p[4]\", \"p[5]\", \"p[6]\", \"p[7]\", \"p[8]\", \"p[9]\", \n                      \"p[10]\", \"p[11]\", \"p[12]\", \"p[13]\", \"p[14]\")]) %>%\n  gather(key = \"param\", value = \"value\") %>% mutate(param = fct_rev(as_factor(param))) %>% \n  ggplot(aes(x = value, y = param, height = stat(density), fill = param)) + \n  geom_density_ridges(scale = 1.3, stat = \"density\", alpha = 0.8) +\n  scale_fill_manual(values = rev(mycols2)) + scale_y_discrete(labels = rev(names.covars.new), expand = expand_scale(mult = c(0.01, .07))) +\n  ylab(\"Environmental driver\") + xlab(expression(paste(\"Proportional effect at age-0 vs. age-1 (\", rho, \")\"))) +\n  theme_bw() + theme(legend.position = \"none\", axis.text = element_text(color = \"black\"), \n        legend.key.spacing.y = unit(0, \"cm\"), legend.key.spacing.x = unit(1, \"cm\"), legend.margin = margin(0,0,0,0), panel.grid = element_blank())  + \n  guides(color = guide_legend(nrow = 2, byrow = TRUE))\ndev.off()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npng \n  2 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n#### Ricker a\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggs_caterpillar(D = mod.gg %>% filter(Parameter %in% paste(\"A[\", 1:13, \"]\", sep = \"\")), family = \"A\", thick_ci = c(0.125, 0.875), thin_ci = c(0.025, 0.975), sort = FALSE) + theme_bw() + theme(axis.text = element_text(color = \"black\")) + ylab(\"Population\") + xlab(\"Ricker a\") + scale_y_discrete(labels = rev(popshort), limits = rev)\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-72-1.png){width=480}\n:::\n:::\n\n\n\n\n\n\n\n\n#### River b\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggs_caterpillar(D = mod.gg %>% filter(Parameter %in% paste(\"B[\", 1:13, \"]\", sep = \"\")), family = \"B\", thick_ci = c(0.125, 0.875), thin_ci = c(0.025, 0.975), sort = FALSE) + theme_bw() + theme(axis.text = element_text(color = \"black\")) + ylab(\"Population\") + xlab(\"Ricker b\") + scale_y_discrete(labels = rev(popshort), limits = rev)\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-74-1.png){width=384}\n:::\n:::\n\n\n\n\n\n\n\n\n\n#### Observation error\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggs_caterpillar(D = mod.gg, family = \"sigma.oe\", thick_ci = c(0.125, 0.875), thin_ci = c(0.025, 0.975), sort = FALSE) + \n  theme_bw() + theme(axis.text = element_text(color = \"black\")) + ylab(\"\") + xlab(\"Observation error\") + scale_y_discrete(labels = \"Global\")\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-76-1.png){width=480}\n:::\n:::\n\n\n\n\n\n\n\n\n\n#### Process error\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggs_caterpillar(D = mod.gg, family = \"sigma.pe\", thick_ci = c(0.125, 0.875), thin_ci = c(0.025, 0.975), sort = FALSE) + \n  theme_bw() + theme(axis.text = element_text(color = \"black\")) + ylab(\"Population\") + xlab(\"Process error\") + scale_y_discrete(labels = rev(popshort), limits = rev)\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-78-1.png){width=384}\n:::\n:::\n\n\n\n\n\n\n\n\n\n#### Carrying capacity\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggs_caterpillar(D = mod.gg, family = \"K\", thick_ci = c(0.125, 0.875), thin_ci = c(0.025, 0.975), sort = FALSE) + \n  theme_bw() + theme(axis.text = element_text(color = \"black\")) + ylab(\"Population\") + xlab(\"Carrying capacity (redds / km)\") + scale_y_discrete(labels = rev(popshort), limits = rev)\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-80-1.png){width=384}\n:::\n:::\n\n\n\n\n\n\n\n\n\n#### Phi - autocorrelated residuls\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggs_caterpillar(D = mod.gg, family = \"phi\", thick_ci = c(0.125, 0.875), thin_ci = c(0.025, 0.975), sort = FALSE) + \n  theme_bw() + theme(axis.text = element_text(color = \"black\")) + ylab(\"Population\") + xlab(\"AR1\") + scale_y_discrete(labels = rev(popshort), limits = rev) + geom_vline(xintercept = 0, linetype = \"dashed\") \n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-82-1.png){width=384}\n:::\n:::\n\n\n\n\n\n\n\n\n#### Sigma a\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggs_caterpillar(D = mod.gg, family = \"sigma.A\", thick_ci = c(0.125, 0.875), thin_ci = c(0.025, 0.975), sort = FALSE) + \n  theme_bw() + theme(axis.text = element_text(color = \"black\")) + ylab(\"\") + xlab(\"\") + geom_vline(xintercept = 0, linetype = \"dashed\") \n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-84-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\n### Marginal effects\n\nLoad in covariate mean/SD summaries, to transform axes to real scale\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncovsrc_jldq_summary <- read_csv(\"Data/Derived/ManagedFlow_SummaryMeanSD_1967-2022.csv\")\ncovsrc_natq_summary <- read_csv(\"Data/Derived/NaturalFlow_SummaryMeanSD_1975-2022.csv\")\ncovsrc_expq_summary <- read_csv(\"Data/Derived/ExperiencedFlow_SummaryMeanSD_1975-2022.csv\")\ncovsrc_temp_summary <- read_csv(\"Data/Derived/Temperature_SummaryMeanSD_1967-2022.csv\")\ncovsummary <- rbind(covsrc_jldq_summary[c(1,2,6:9),], covsrc_natq_summary[c(6:7),], covsrc_temp_summary)\ncovsummary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n   cov                        mean        sd\n   <chr>                     <dbl>     <dbl>\n 1 z_jld_rampdur           10.0       5.71  \n 2 z_jld_rampratemindoy   270.        7.92  \n 3 z_jld_winvar             0.0431    0.0649\n 4 z_jld_summean         2700.      838.    \n 5 z_jld_peakmag         5885.     1921.    \n 6 z_jld_peaktime         286.       15.9   \n 7 z_natq_peakmag       10948.     3603.    \n 8 z_natq_peaktime        278.       11.9   \n 9 z_temp_falmean           4.05      1.04  \n10 z_temp_winmean          -9.29      1.80  \n11 z_temp_sprmean           2.38      1.30  \n12 z_temp_summean          14.8       1.14  \n```\n\n\n:::\n:::\n\n\n\n\n\n\nValues for prediction and color palettes\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnvalues <- 100\ncolPal <- hcl.colors(length(pops), \"Spectral\")\n```\n:::\n\n\n\n\n\n\n\n::: panel-tabset\n\n#### JLD ramp duration\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_jld_rampdur), to = max(dat$z_jld_rampdur), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = \"Duration of ramp down (days)\", ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$jld_rampdur)\nx.axis <- seq(from = 5, to = 30, by = 5)\nx.axis.scaled <- (x.axis - covsummary$mean[1]) / covsummary$sd[1]\naxis(1, at = x.axis.scaled, labels = x.axis)\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[1]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.025)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.125)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.975)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",1]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"10\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[1])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-88-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n#### JLD ramp timing\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_jld_rampratemindoy), to = max(dat$z_jld_rampratemindoy), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = \"Timing of ramp down\", ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$jld_rampratemindoy)\nx.axis <- c(254,264,274)\nx.axis.scaled <- (x.axis - covsummary$mean[2]) / covsummary$sd[2]\naxis(1, at = x.axis.scaled, labels = c(\"10 Sept\", \"20 Sept\", \"30 Sept\"))\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[2]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.025)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.125)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.975)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",2]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"26 Sept\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[2])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-89-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n#### JLD winter variation\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_jld_winvar, na.rm = TRUE), to = max(dat$z_jld_winvar, na.rm = TRUE), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = \"Mgd. winter flow variation\", ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$jld_winvar, na.rm = T)\nx.axis <- seq(from = 0, to = 0.3, by = 0.05)\nx.axis.scaled <- (x.axis - covsummary$mean[3]) / covsummary$sd[3]\naxis(1, at = x.axis.scaled, labels = c(\"0.00\", \"0.05\", \"0.10\", \"0.15\", \"0.20\", \"0.25\", \"0.30\"))\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[3]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.025)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.225)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.975)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",3]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"0.043\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[3])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-90-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n#### JLD summer flow\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_jld_summean, na.rm = TRUE), to = max(dat$z_jld_summean, na.rm = TRUE), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = \"Mgd. summer mean flow (cfs)\", ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$jld_summean, na.rm = T)\nx.axis <- seq(from = 1500, to = 4500, by = 1000)\nx.axis.scaled <- (x.axis - covsummary$mean[4]) / covsummary$sd[4]\naxis(1, at = x.axis.scaled, labels = x.axis)\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[4]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.025)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.125)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.975)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",4]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"2700\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[4])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-91-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n#### JLD peak flow mag.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# JLD Peak flow magnitude\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_jld_peakmag, na.rm = TRUE), to = max(dat$z_jld_peakmag, na.rm = TRUE), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = \"Mgd. peak flow magnitude (cfs)\", ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$jld_peakmag, na.rm = T)\nx.axis <- seq(from = 4000, to = 12000, by = 2000)\nx.axis.scaled <- (x.axis - covsummary$mean[5]) / covsummary$sd[5]\naxis(1, at = x.axis.scaled, labels = round((x.axis), digits = 0))\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[5]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.025)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.125)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.975)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",5]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n\n# interaction with natural peak magnitude\n## minimum\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[5]\"]*x1 + Mcmcdat[j,\"mu.coef[7]\"]*min(dat$z_natq_peakmag, na.rm = T) + Mcmcdat[j,\"mu.coef[13]\"]*x1*min(dat$z_natq_peakmag, na.rm = T) }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \nlines(pred_median ~ x1, lty = 3, lwd = 2, type = \"l\")\n## maximum\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[5]\"]*x1 + Mcmcdat[j,\"mu.coef[7]\"]*max(dat$z_natq_peakmag, na.rm = T) + Mcmcdat[j,\"mu.coef[13]\"]*x1*max(dat$z_natq_peakmag, na.rm = T) }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \nlines(pred_median ~ x1, lty = 2, lwd = 2, type = \"l\")\nlegend(\"topright\", legend = c(\"Min. nat. peak flow\", \"Max. nat. peak flow\"), lwd = 2, lty = c(3,2), bty = \"n\", cex = 0.75)\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"5884\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[5])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-92-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n#### JLD peak flow timing\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_jld_peaktime, na.rm = TRUE), to = max(dat$z_jld_peaktime, na.rm = TRUE), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = \"Mgd. peak flow timing\", ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$jld_peaktime, na.rm = T)\nx.axis <- c(242, 273, 303)\nx.axis.scaled <- (x.axis - covsummary$mean[6]) / covsummary$sd[6]\naxis(1, at = x.axis.scaled, labels = c(\"1 May\", \"1 June\", \"1 July\"))\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[6]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.025)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.125)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.975)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",6]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n\n# interaction with natural peak magnitude\n## minimum\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[6]\"]*x1 + Mcmcdat[j,\"mu.coef[8]\"]*min(dat$z_natq_peaktime, na.rm = T) + Mcmcdat[j,\"mu.coef[14]\"]*x1*min(dat$z_natq_peaktime, na.rm = T) }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \nlines(pred_median ~ x1, lty = 3, lwd = 2, type = \"l\")\n## maximum\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[6]\"]*x1 + Mcmcdat[j,\"mu.coef[8]\"]*max(dat$z_natq_peaktime, na.rm = T) + Mcmcdat[j,\"mu.coef[14]\"]*x1*max(dat$z_natq_peaktime, na.rm = T) }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \nlines(pred_median ~ x1, lty = 2, lwd = 2, type = \"l\")\nlegend(\"topleft\", legend = c(\"Min. nat. peak time\", \"Max. nat. peak time\"), lwd = 2, lty = c(3,2), bty = \"n\", cex = 0.75)\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"14 June\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[6])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-93-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n#### Nat peak flow mag.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_natq_peakmag, na.rm = TRUE), to = max(dat$z_natq_peakmag, na.rm = TRUE), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = \"Natural peak flow magnitude (cfs)\", ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$natq_peakmag, na.rm = T)\nx.axis <- seq(from = 5000, to = 20000, by = 5000)\nx.axis.scaled <- (x.axis - covsummary$mean[7]) / covsummary$sd[7]\naxis(1, at = x.axis.scaled, labels = round((x.axis), digits = 0))\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[7]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.025)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.125)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.975)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",7]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n\n# interaction with natural peak magnitude\n## minimum\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[7]\"]*x1 + Mcmcdat[j,\"mu.coef[5]\"]*min(dat$z_jld_peakmag, na.rm = T) + Mcmcdat[j,\"mu.coef[13]\"]*x1*min(dat$z_jld_peakmag, na.rm = T) }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \nlines(pred_median ~ x1, lty = 3, lwd = 2, type = \"l\")\n## maximum\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[7]\"]*x1 + Mcmcdat[j,\"mu.coef[5]\"]*max(dat$z_jld_peakmag, na.rm = T) + Mcmcdat[j,\"mu.coef[13]\"]*x1*max(dat$z_jld_peakmag, na.rm = T) }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \nlines(pred_median ~ x1, lty = 2, lwd = 2, type = \"l\")\nlegend(\"topright\", legend = c(\"Min. JLD peak flow\", \"Max. JLD peak flow\"), lwd = 2, lty = c(3,2), bty = \"n\", cex = 0.75)\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"10948\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[7])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-94-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n#### Nat peak flow timing\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_natq_peaktime, na.rm = TRUE), to = max(dat$z_natq_peaktime, na.rm = TRUE), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = \"Natural peak flow timing\", ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$natq_peaktime, na.rm = T)\nx.axis <- c(256, 273, 287, 303)\nx.axis.scaled <- (x.axis - covsummary$mean[8]) / covsummary$sd[8]\naxis(1, at = x.axis.scaled, labels = c(\"15 May\", \"1 June\", \"15 June\", \"1 July\"))\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[8]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.025)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.125)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.975)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",8]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n\n# interaction with natural peak timing\n## minimum\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[8]\"]*x1 + Mcmcdat[j,\"mu.coef[6]\"]*min(dat$z_jld_peaktime, na.rm = T) + Mcmcdat[j,\"mu.coef[14]\"]*x1*min(dat$z_jld_peaktime, na.rm = T) }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \nlines(pred_median ~ x1, lty = 3, lwd = 2, type = \"l\")\n## maximum\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[8]\"]*x1 + Mcmcdat[j,\"mu.coef[6]\"]*max(dat$z_jld_peaktime, na.rm = T) + Mcmcdat[j,\"mu.coef[14]\"]*x1*max(dat$z_jld_peaktime, na.rm = T) }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \nlines(pred_median ~ x1, lty = 2, lwd = 2, type = \"l\")\nlegend(\"topright\", legend = c(\"Min. JLD peak time\", \"Max. JLD peak time\"), lwd = 2, lty = c(3,2), bty = \"n\", cex = 0.75)\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"5 June\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[8])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-95-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n#### Autumn temperature\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_temp_falmean, na.rm = TRUE), to = max(dat$z_temp_falmean, na.rm = TRUE), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = expression(paste(\"Autumn temperature (\"^\"o\", \"C)\", sep = \"\")), ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$temp_falmean, na.rm = T)\nx.axis <- seq(from = 2, to = 6, by = 1)\nx.axis.scaled <- (x.axis - covsummary$mean[9]) / covsummary$sd[9]\naxis(1, at = x.axis.scaled, labels = x.axis)\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[9]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.05)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.125)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.975)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",9]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"4.05\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[9])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-96-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n#### Winter temperature\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_temp_winmean, na.rm = TRUE), to = max(dat$z_temp_winmean, na.rm = TRUE), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = expression(paste(\"Winter temperature (\"^\"o\", \"C)\", sep = \"\")), ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$temp_winmean, na.rm = T)\nx.axis <- seq(from = -13, to = 5, by = 2)\nx.axis.scaled <- (x.axis - covsummary$mean[10]) / covsummary$sd[10]\naxis(1, at = x.axis.scaled, labels = x.axis)\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[10]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.025)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.125)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.925)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",10]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"-9.29\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[10])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-97-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n#### Spring temperature\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_temp_sprmean, na.rm = TRUE), to = max(dat$z_temp_sprmean, na.rm = TRUE), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = expression(paste(\"Spring temperature (\"^\"o\", \"C)\", sep = \"\")), ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$temp_sprmean, na.rm = T)\nx.axis <- seq(from = 0, to = 5, by = 1)\nx.axis.scaled <- (x.axis - covsummary$mean[11]) / covsummary$sd[11]\naxis(1, at = x.axis.scaled, labels = x.axis)\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[11]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.025)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.125)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.975)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",11]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"2.38\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[11])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-98-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n#### Summer temperature\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(4,4,2.5,0.5), mgp = c(2.25,0.8,0))\n# set up plot\nx1 <- seq(from = min(dat$z_temp_summean, na.rm = TRUE), to = max(dat$z_temp_summean, na.rm = TRUE), length.out = nvalues)\nplot(seq(from = 0.3, to = 2, length.out = nvalues) ~ x1, pch = NA, bty = \"l\", xlab = expression(paste(\"Summer temperature (\"^\"o\", \"C)\", sep = \"\")), ylab = \"Productivity, ln(R/S)\", axes = F)\n# axes and box\n# range(dat$temp_summean, na.rm = T)\nx.axis <- seq(from = 12, to = 17, by = 1)\nx.axis.scaled <- (x.axis - covsummary$mean[12]) / covsummary$sd[12]\naxis(1, at = x.axis.scaled, labels = x.axis)\naxis(2)\n# predictions\npred <- matrix(NA, nrow = nrow(Mcmcdat), ncol = nvalues)\nfor (j in 1:nrow(pred)) { pred[j,] <- Mcmcdat[j,\"mu.A\"] + Mcmcdat[j,\"mu.coef[12]\"]*x1 }\npred_median <- apply(pred, MARGIN = 2, quantile, prob = 0.50) \npred_025 <- apply(pred, MARGIN = 2, quantile, prob = 0.025)\npred_125 <- apply(pred, MARGIN = 2, quantile, prob = 0.125)\npred_875 <- apply(pred, MARGIN = 2, quantile, prob = 0.875)\npred_975 <- apply(pred, MARGIN = 2, quantile, prob = 0.975)\npolygon(c(x1, rev(x1)), c(pred_975, rev(pred_025)), col = \"grey85\", lty=0)\npolygon(c(x1, rev(x1)), c(pred_875, rev(pred_125)), col = \"grey70\", lty=0)\n# add population-specific fits\n# for (i in 1:n.pops) { lines(param.summary[paste(\"A[\", i, \"]\", sep = \"\"),5] + param.summary[paste(\"coef[\", i, \",12]\", sep = \"\"),5]*x1 ~ x1, col = colPal[i], lwd = 1) }\n# add global fit\nlines(pred_median ~ x1, col = \"black\", lwd = 3, type = \"l\")\n# median productivity\nabline(h = param.summary[\"mu.A\",5], lty = 3, col = \"grey40\")\nabline(v = 0, lty = 3, col = \"grey40\")\ntext(x = 0, y = 0.3, labels = \"14.81\", pos = 4, col = \"grey40\")\n# lines(density((median(Mcmcdat[,\"mu.A\"]) - Mcmcdat[,\"mu.A\"]) / Mcmcdat[,\"mu.coef[1]\"]))\n# legend\npar(xpd = TRUE, usr = c(0,1,0,1))\n# legend(0.085, 1.15, legend = popshort, lwd = 1, col = colPal, ncol = 5, cex = 0.5, bg = \"grey85\")\nbox(bty = \"o\", lwd = 3, col = mycols2[12])\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-99-1.png){width=408}\n:::\n:::\n\n\n\n\n\n\n:::\n\n\n\nWrite plots to file...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### Interactions\n\nGet raw covariate data for plotting\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmgdcovs <- read_csv(\"Data/Derived/JLD_ManagedFlow_Covariates_BroodYear_1960-2022.csv\") %>% \n  select(broodyr, jld_peakmag, jld_peaktime) %>%\n  mutate(z_jld_peakmag = (jld_peakmag - covsummary$mean[5])/covsummary$sd[5],\n         z_jld_peaktime = (jld_peaktime - covsummary$mean[6])/covsummary$sd[6])\n\nnatcovs <- read_csv(\"Data/Derived/SnakeTribs_NaturalFlow_Covariates_BroodYear_1960-2022.csv\") %>% \n  filter(site == \"SnakeNat\") %>% \n  select(broodyr, natq_peakmag, natq_peaktime) %>%\n  mutate(z_natq_peakmag = (natq_peakmag - covsummary$mean[7])/covsummary$sd[7],\n         z_natq_peaktime = (natq_peaktime - covsummary$mean[8])/covsummary$sd[8])\n\nmycovdat <- mgdcovs %>% left_join(natcovs)\n```\n:::\n\n\n\n\n\n\nNumber of values for calculation\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnvalues <- 100\n```\n:::\n\n\n\n\n\n\n\n#### Peak flow magnitude\n\nGenerate sequences of predictor data and transform to original scale\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxjld <- seq(from = min(dat$z_jld_peakmag, na.rm = TRUE), to = max(dat$z_jld_peakmag, na.rm = TRUE), length.out = nvalues)\nxnat <- seq(from = min(dat$z_natq_peakmag, na.rm = TRUE), to = max(dat$z_natq_peakmag, na.rm = TRUE), length.out = nvalues)\nxjld.real <- (xjld * covsummary$sd[5]) + covsummary$mean[5]\nxnat.real <- (xnat * covsummary$sd[7]) + covsummary$mean[7]\n```\n:::\n\n\n\n\n\n\nSet up axes\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxjld.axis <- seq(from = 4000, to = 12000, by = 2000)\nxjld.axis.scaled <- (xjld.axis - covsummary$mean[5]) / covsummary$sd[5]\n\nxnat.axis <- seq(from = 5000, to = 20000, by = 5000)\nxnat.axis.scaled <- (xnat.axis - covsummary$mean[7]) / covsummary$sd[7]\n```\n:::\n\n\n\n\n\n\nPredict productivity from model\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- matrix(data = NA, nrow = nvalues, ncol = nvalues) # matrix of predictions\ncom <- matrix(data = NA, nrow = nvalues, ncol = nvalues) # matrix of combined flow\nfor(i in 1:nvalues) {\n  for(j in 1:nvalues) {\n    z[i,j] <- param.summary[\"mu.coef[5]\",5]*xjld[i] + param.summary[\"mu.coef[7]\",5]*xnat[j] + param.summary[\"mu.coef[13]\",5]*xjld[i]*xnat[j]\n    com[i,j] <- (xjld.real[i]) + (xnat.real[j])\n  }\n  }\nz.cont <- ifelse(z < 0, 0, z) # trick for plotting single contour\nrange(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.2687132  0.1940241\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPlot set up\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylevels <- seq(-1, 1, by = 0.1) # specify location and number of breaks for plotting\nmycols <- rev(hcl.colors(length(mylevels)-1, \"Blue-Red 3\"))\nmyddd <- mycovdat %>% select(z_natq_peakmag, z_jld_peakmag) %>% filter(!is.na(z_natq_peakmag))\nmyhull <- chull(myddd)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(5,5,1,1), mgp = c(3.5,1,0))\nfilled.contour(x = xnat, y = xjld, z = t(z),\n               plot.title = {\n                 title(xlab = \"Natural peak flow magnitude (cfs)\")\n                 title(ylab = \"Managed peak flow magnitude (cfs)\")\n               },\n               levels = mylevels,\n               col = mycols,\n               plot.axes = {\n                 contour(x = xnat, y = xjld, z = t(z), levels = 0, lty = 3, lwd = 1, col = \"grey40\",\n                         drawlabels = F, axes = F, frame.plot = F, add = T);\n                 segments(myddd$z_natq_peakmag[myhull], myddd$z_jld_peakmag[myhull],\n                          myddd$z_natq_peakmag[c(myhull[length(myhull)], myhull[-length(myhull)])],\n                          myddd$z_jld_peakmag[c(myhull[length(myhull)], myhull[-length(myhull)])],\n                          col = \"grey40\", lwd = 2) # Draw convex hull lines\n                 axis(1, at = xnat.axis.scaled, labels = xnat.axis); \n                 axis(2, at = xjld.axis.scaled, labels = xjld.axis)\n               })\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-107-1.png){width=576}\n:::\n:::\n\n\n\n\n\n\n\n\n\n#### Peak flow timing\n\nGenerate sequences of predictor data and transform to original scale\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxjld <- seq(from = min(dat$z_jld_peaktime, na.rm = TRUE), to = max(dat$z_jld_peaktime, na.rm = TRUE), length.out = nvalues)\nxnat <- seq(from = min(dat$z_natq_peaktime, na.rm = TRUE), to = max(dat$z_natq_peaktime, na.rm = TRUE), length.out = nvalues)\nxjld.real <- (xjld * covsummary$sd[6]) + covsummary$mean[6]\nxnat.real <- (xnat * covsummary$sd[8]) + covsummary$mean[8]\n```\n:::\n\n\n\n\n\n\nSet up axes\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxjld.axis <- c(242, 273, 303)\nxjld.axis.scaled <- (xjld.axis - covsummary$mean[6]) / covsummary$sd[6]\nxjld.axis.labels <- c(\"1 May\", \"1 June\", \"1 July\")\n\nxnat.axis <- c(256, 273, 287, 303)\nxnat.axis.scaled <- (xnat.axis - covsummary$mean[8]) / covsummary$sd[8]\nxnat.axis.labels <- c(\"15 May\", \"1 June\", \"15 June\", \"1 July\")\n```\n:::\n\n\n\n\n\n\nPredict productivity from model\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- matrix(data = NA, nrow = nvalues, ncol = nvalues) # matrix of predictions\ncom <- matrix(data = NA, nrow = nvalues, ncol = nvalues) # matrix of combined flow\nfor(i in 1:nvalues) {\n  for(j in 1:nvalues) {\n    z[i,j] <- param.summary[\"mu.coef[6]\",5]*xjld[i] + param.summary[\"mu.coef[8]\",5]*xnat[j] + param.summary[\"mu.coef[14]\",5]*xjld[i]*xnat[j]\n  }\n  }\nz.cont <- ifelse(z < 0, 0, z) # trick for plotting single contour\nrange(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.7522073  0.8330047\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPlot set up\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylevels <- seq(-1, 1, by = 0.1) # specify location and number of breaks for plotting\nmycols <- rev(hcl.colors(length(mylevels)-1, \"Blue-Red 3\"))\nmyddd <- mycovdat %>% select(z_natq_peaktime, z_jld_peaktime) %>% filter(!is.na(z_natq_peaktime), !is.na(z_jld_peaktime))\nmyhull <- chull(myddd)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(5,5,1,1), mgp = c(3.5,1,0))\nfilled.contour(x = xnat, y = xjld, z = t(z),\n               plot.title = {\n                 title(xlab = \"Natural peak flow timing\")\n                 title(ylab = \"Managed peak flow timing\")\n               },\n               levels = mylevels,\n               col = mycols,\n               plot.axes = {\n                 contour(x = xnat, y = xjld, z = t(z), levels = 0, lty = 3, lwd = 1, col = \"grey40\",\n                         drawlabels = F, axes = F, frame.plot = F, add = T);\n                 segments(myddd$z_natq_peaktime[myhull], myddd$z_jld_peaktime[myhull],\n                          myddd$z_natq_peaktime[c(myhull[length(myhull)], myhull[-length(myhull)])],\n                          myddd$z_jld_peaktime[c(myhull[length(myhull)], myhull[-length(myhull)])],\n                          col = \"grey40\", lwd = 2) # Draw convex hull lines\n                 axis(1, at = xnat.axis.scaled, labels = xnat.axis.labels);\n                 axis(2, at = xjld.axis.scaled, labels = xjld.axis.labels)\n               })\n```\n\n::: {.cell-output-display}\n![](ReddCountsRicker_files/figure-html/unnamed-chunk-113-1.png){width=576}\n:::\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/datatables-binding-0.33/datatables.js\"></script>\n<script src=\"site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js\"></script>\n<link href=\"site_libs/crosstalk-1.2.1/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/crosstalk-1.2.1/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}